import 'dart:convert';
import 'dart:math' as math;
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:http/http.dart' as http;
import '../models/point_of_interest.dart';

class MapService extends ChangeNotifier {
  GoogleMapController? _controller;
  Set<Marker> _markers = {};
  Set<Polyline> _polylines = {};
  List<PointOfInterest> _pois = [];
  List<PointOfInterest> _filteredPois = [];
  bool _isNavigating = false;
  PointOfInterest? _selectedPoi;
  Marker? _userLocationMarker;

  // Google API Key - Directions API i√ßin
  static const String _apiKey = 'AIzaSyDWVBfYxASYj1aTqcS8pvHa67IDic4wthk';

  // Kayseri Millet Bah√ßesi merkez koordinatlarƒ± (WC'lerin ortasƒ±)
  static const LatLng kayseriMilletBahcesi = LatLng(38.704200, 35.509500);

  // Getters
  GoogleMapController? get controller => _controller;
  Set<Marker> get markers => _getAllMarkers();
  Set<Polyline> get polylines => _polylines;
  List<PointOfInterest> get pois => _pois;
  List<PointOfInterest> get filteredPois => _filteredPois;
  bool get isNavigating => _isNavigating;
  PointOfInterest? get selectedPoi => _selectedPoi;

  // T√ºm marker'larƒ± (POI + kullanƒ±cƒ± konumu) d√∂nd√ºr
  Set<Marker> _getAllMarkers() {
    Set<Marker> allMarkers = Set.from(_markers);
    if (_userLocationMarker != null) {
      allMarkers.add(_userLocationMarker!);
    }
    return allMarkers;
  }

  void setController(GoogleMapController controller) {
    _controller = controller;
    notifyListeners();
  }

  Future<void> initializePOIs() async {
    _pois = POIData.kayseriMilletBahcesi;
    _filteredPois = List.from(_pois);
    // Cache'i temizle ki yeni boyuttaki marker'lar olu≈üturulsun
    _markerCache.clear();
    await _createMarkers();
    notifyListeners();
  }

  Future<void> _createMarkers() async {
    _markers.clear();
    
    for (PointOfInterest poi in _pois) {
      final icon = await _getMarkerIcon(poi.category);
      _markers.add(
        Marker(
          markerId: MarkerId(poi.id),
          position: LatLng(poi.latitude, poi.longitude),
          infoWindow: InfoWindow(
            title: poi.name,
            snippet: poi.description,
            onTap: () => selectPOI(poi),
          ),
          icon: icon,
          onTap: () => selectPOI(poi),
        ),
      );
    }
  }

  // Custom marker cache
  final Map<String, BitmapDescriptor> _markerCache = {};

  Future<BitmapDescriptor> _getMarkerIcon(String category) async {
    // Cache'den kontrol et
    if (_markerCache.containsKey(category)) {
      return _markerCache[category]!;
    }

    BitmapDescriptor icon;
    
    switch (category.toLowerCase()) {
      case 'kapƒ±':
        icon = await _createCustomMarker(Icons.login, const Color(0xFF3252a8));
        break;
      case 'wc':
        icon = await _createCustomMarker(Icons.wc, const Color(0xFF3252a8));
        break;
      case '√ºniversite':
        icon = await _createUniversityMarker();
        break;
      default:
        icon = await _createCustomMarker(Icons.location_on, const Color(0xFF3252a8));
        break;
    }
    
    // Cache'e kaydet
    _markerCache[category] = icon;
    return icon;
  }

  Future<BitmapDescriptor> _createCustomMarker(IconData iconData, Color color) async {
    final pictureRecorder = ui.PictureRecorder();
    final canvas = Canvas(pictureRecorder);
    const size = Size(30, 30);

    // Beyaz daire arka plan
    final backgroundPaint = Paint()..color = Colors.white;
    canvas.drawCircle(
      Offset(size.width / 2, size.height / 2),
      size.width / 2 - 1.2,
      backgroundPaint,
    );

    // Mavi √ßer√ßeve
    final borderPaint = Paint()
      ..color = color
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.8;
    canvas.drawCircle(
      Offset(size.width / 2, size.height / 2),
      size.width / 2 - 1.2,
      borderPaint,
    );

    // Icon √ßiz
    final textPainter = TextPainter(textDirection: TextDirection.ltr);
    textPainter.text = TextSpan(
      text: String.fromCharCode(iconData.codePoint),
      style: TextStyle(
        fontSize: 12,
        fontFamily: iconData.fontFamily,
        color: color,
      ),
    );
    textPainter.layout();
    textPainter.paint(
      canvas,
      Offset(
        (size.width - textPainter.width) / 2,
        (size.height - textPainter.height) / 2,
      ),
    );

    final picture = pictureRecorder.endRecording();
    final image = await picture.toImage(size.width.toInt(), size.height.toInt());
    final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
    final uint8List = byteData!.buffer.asUint8List();

    return BitmapDescriptor.bytes(uint8List);
  }

  Future<BitmapDescriptor> _createUniversityMarker() async {
    final pictureRecorder = ui.PictureRecorder();
    final canvas = Canvas(pictureRecorder);
    const size = Size(50, 50);

    // Beyaz daire arka plan
    final backgroundPaint = Paint()..color = Colors.white;
    canvas.drawCircle(
      Offset(size.width / 2, size.height / 2),
      size.width / 2 - 2,
      backgroundPaint,
    );

    // NNY Logo √ßer√ßevesi (mavi gradient)
    final gradientPaint = Paint()
      ..shader = const LinearGradient(
        colors: [
          Color(0xFF1e3a5f),
          Color(0xFF3252a8),
        ],
      ).createShader(Rect.fromCircle(
        center: Offset(size.width / 2, size.height / 2),
        radius: size.width / 2 - 2,
      ));
    
    canvas.drawCircle(
      Offset(size.width / 2, size.height / 2),
      size.width / 2 - 2,
      gradientPaint,
    );

    // Beyaz i√ß √ßer√ßeve
    final innerBorderPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2;
    canvas.drawCircle(
      Offset(size.width / 2, size.height / 2),
      size.width / 2 - 5,
      innerBorderPaint,
    );

    // Mini daƒü simgesi (t√ºrkuaz) - b√ºy√ºt√ºlm√º≈ü
    final mountainPaint = Paint()
      ..color = const Color(0xFF00bcd4)
      ..style = PaintingStyle.fill;

    final mountainPath = Path()
      ..moveTo(14, 28)
      ..lineTo(19, 18)
      ..lineTo(25, 22)
      ..lineTo(31, 15)
      ..lineTo(36, 28)
      ..close();

    canvas.drawPath(mountainPath, mountainPaint);

    // NNY yazƒ±sƒ± - b√ºy√ºt√ºlm√º≈ü
    final textPainter = TextPainter(textDirection: TextDirection.ltr);
    textPainter.text = const TextSpan(
      text: 'NNY',
      style: TextStyle(
        fontSize: 10,
        fontWeight: FontWeight.bold,
        color: Colors.white,
        letterSpacing: 0.7,
      ),
    );
    textPainter.layout();
    textPainter.paint(
      canvas,
      Offset(
        (size.width - textPainter.width) / 2,
        size.height / 2 + 3,
      ),
    );

    // Alt √ßizgi - b√ºy√ºt√ºlm√º≈ü
    final linePaint = Paint()
      ..color = Colors.white
      ..strokeWidth = 1.5;
    canvas.drawLine(
      const Offset(12, 38),
      const Offset(38, 38),
      linePaint,
    );

    // 2009 yazƒ±sƒ± - b√ºy√ºt√ºlm√º≈ü
    textPainter.text = const TextSpan(
      text: '2009',
      style: TextStyle(
        fontSize: 5,
        color: Colors.white70,
        fontWeight: FontWeight.w500,
      ),
    );
    textPainter.layout();
    textPainter.paint(
      canvas,
      Offset(
        (size.width - textPainter.width) / 2,
        41,
      ),
    );

    final picture = pictureRecorder.endRecording();
    final image = await picture.toImage(size.width.toInt(), size.height.toInt());
    final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
    final uint8List = byteData!.buffer.asUint8List();

    return BitmapDescriptor.bytes(uint8List);
  }

  void selectPOI(PointOfInterest poi) {
    _selectedPoi = poi;
    
    // Haritayƒ± se√ßili POI'ye odakla
    _controller?.animateCamera(
      CameraUpdate.newLatLngZoom(
        LatLng(poi.latitude, poi.longitude),
        18.0,
      ),
    );
    
    notifyListeners();
  }

  Future<void> startNavigation(PointOfInterest destination, LatLng userLocation) async {
    _isNavigating = true;
    _selectedPoi = destination;
    
    print('Navigasyon ba≈ülatƒ±lƒ±yor: ${userLocation.latitude}, ${userLocation.longitude} -> ${destination.latitude}, ${destination.longitude}');
    
    // Kullanƒ±cƒ± konum marker'ƒ±nƒ± olu≈ütur
    await _createUserLocationMarker(userLocation);
    
    // Haritayƒ± kullanƒ±cƒ± konumuna odakla
    await _focusOnUserLocation(userLocation);
    
    try {
      await _getDirections(userLocation, LatLng(destination.latitude, destination.longitude));
    } catch (e) {
      debugPrint('Navigasyon hatasƒ±: $e');
      
      // Hata durumunda basit d√ºz √ßizgi √ßiz
      _createStraightLine(userLocation, LatLng(destination.latitude, destination.longitude));
    }
    
    notifyListeners();
  }

  Future<void> _getDirections(LatLng origin, LatLng destination) async {
    print('üó∫Ô∏è Google Directions API √ßaƒürƒ±sƒ± ba≈ülatƒ±lƒ±yor...');
    print('üìç Ba≈ülangƒ±√ß: ${origin.latitude}, ${origin.longitude}');
    print('üéØ Hedef: ${destination.latitude}, ${destination.longitude}');
    
    final url = Uri.parse(
      'https://maps.googleapis.com/maps/api/directions/json?'
      'origin=${origin.latitude},${origin.longitude}&'
      'destination=${destination.latitude},${destination.longitude}&'
      'mode=walking&'
      'language=tr&'
      'region=tr&'
      'units=metric&'
      'key=$_apiKey'
    );

    print('üåê API URL: $url');

    try {
      final response = await http.get(url, headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json',
      });
      
      print('üì° HTTP Status: ${response.statusCode}');
      
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        print('‚úÖ API Response Status: ${data['status']}');
        
        if (data['status'] == 'OK' && data['routes'].isNotEmpty) {
          final route = data['routes'][0];
          
          // Route bilgilerini log'la
          if (route['legs'] != null && route['legs'].isNotEmpty) {
            final leg = route['legs'][0];
            print('üö∂ Mesafe: ${leg['distance']['text']}');
            print('‚è±Ô∏è S√ºre: ${leg['duration']['text']}');
            print('üìù Adƒ±mlar: ${leg['steps']?.length ?? 0} adƒ±m');
          }
          
          final polylinePoints = route['overview_polyline']['points'];
          print('üõ§Ô∏è Polyline bulundu (${polylinePoints.length} karakter), yol √ßiziliyor...');
          
          _createPolyline(polylinePoints);
          
          // Route ba≈üarƒ±lƒ± olduƒüunu bildir
          _showRouteSuccess(route);
          
        } else {
          print('‚ùå API Hatasƒ±: ${data['status']}');
          if (data['error_message'] != null) {
            print('üìÑ Hata Detayƒ±: ${data['error_message']}');
          }
          
          // Hata mesajƒ±nƒ± kullanƒ±cƒ±ya g√∂ster
          if (data['status'] == 'ZERO_RESULTS') {
            print('üö´ Bu nokta arasƒ±nda y√ºr√ºme rotasƒ± bulunamadƒ±');
          }
          
          // API hatasƒ± durumunda d√ºz √ßizgi √ßiz
          _createStraightLine(origin, destination);
        }
      } else {
        print('üî¥ HTTP Hatasƒ±: ${response.statusCode}');
        print('üìÑ Response Body: ${response.body}');
        _createStraightLine(origin, destination);
      }
    } catch (e) {
      print('üí• Directions API Network Hatasƒ±: $e');
      _createStraightLine(origin, destination);
    }
  }

  void _showRouteSuccess(Map<String, dynamic> route) {
    try {
      if (route['legs'] != null && route['legs'].isNotEmpty) {
        final leg = route['legs'][0];
        final distance = leg['distance']?['text'] ?? 'Bilinmeyen mesafe';
        final duration = leg['duration']?['text'] ?? 'Bilinmeyen s√ºre';
        
        print('‚úÖ Rota ba≈üarƒ±yla olu≈üturuldu: $distance, $duration');
      }
    } catch (e) {
      print('Route bilgileri parse edilemedi: $e');
    }
  }

  void _createStraightLine(LatLng origin, LatLng destination) {
    print('‚ö†Ô∏è Google Maps rotasƒ± alƒ±namadƒ±, d√ºz √ßizgi √ßiziliyor: $origin -> $destination');
    
    _polylines.clear();
    _polylines.add(
      Polyline(
        polylineId: const PolylineId('fallback_route'),
        points: [origin, destination],
        color: Colors.orange, // Turuncu renk (fallback olduƒüunu g√∂ster)
        width: 4,
        patterns: [PatternItem.dash(20), PatternItem.gap(10)], // Kesikli √ßizgi
        geodesic: true,
      ),
    );
    
    print('üü† Fallback d√ºz rota √ßizildi (turuncu kesikli √ßizgi)');
    notifyListeners();
  }

  void _createPolyline(String encodedPolyline) {
    List<LatLng> polylineCoordinates = _decodePolyline(encodedPolyline);
    print('üõ§Ô∏è Polyline decode edildi: ${polylineCoordinates.length} koordinat noktasƒ±');
    
    if (polylineCoordinates.isEmpty) {
      print('‚ö†Ô∏è Polyline bo≈ü, d√ºz √ßizgi √ßiziliyor');
      return;
    }
    
    // ƒ∞lk ve son noktalarƒ± log'la
    if (polylineCoordinates.isNotEmpty) {
      print('üö© ƒ∞lk nokta: ${polylineCoordinates.first.latitude}, ${polylineCoordinates.first.longitude}');
      print('üèÅ Son nokta: ${polylineCoordinates.last.latitude}, ${polylineCoordinates.last.longitude}');
    }
    
    _polylines.clear();
    _polylines.add(
      Polyline(
        polylineId: const PolylineId('walking_route'),
        points: polylineCoordinates,
        color: const Color(0xFF3252a8), // Mavi tema rengi
        width: 6, // Daha kalƒ±n √ßizgi
        patterns: [], // D√ºz √ßizgi (kesikli deƒüil)
        geodesic: true, // D√ºnya eƒüriliƒüini dikkate al
        startCap: Cap.roundCap,
        endCap: Cap.roundCap,
        jointType: JointType.round,
      ),
    );
    
    print('‚úÖ Google Maps y√ºr√ºme rotasƒ± √ßizildi!');
    notifyListeners();
  }

  List<LatLng> _decodePolyline(String encoded) {
    List<LatLng> polylineCoordinates = [];
    int index = 0, len = encoded.length;
    int lat = 0, lng = 0;

    while (index < len) {
      int b, shift = 0, result = 0;
      do {
        b = encoded.codeUnitAt(index++) - 63;
        result |= (b & 0x1f) << shift;
        shift += 5;
      } while (b >= 0x20);
      int dlat = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));
      lat += dlat;

      shift = 0;
      result = 0;
      do {
        b = encoded.codeUnitAt(index++) - 63;
        result |= (b & 0x1f) << shift;
        shift += 5;
      } while (b >= 0x20);
      int dlng = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));
      lng += dlng;

      polylineCoordinates.add(LatLng(lat / 1E5, lng / 1E5));
    }
    return polylineCoordinates;
  }

  void searchPOIs(String query) {
    if (query.isEmpty) {
      _filteredPois = List.from(_pois);
    } else {
      _filteredPois = _pois
          .where((poi) =>
              poi.name.toLowerCase().contains(query.toLowerCase()) ||
              poi.category.toLowerCase().contains(query.toLowerCase()) ||
              poi.description.toLowerCase().contains(query.toLowerCase()))
          .toList();
    }
    notifyListeners();
  }

  void stopNavigation() {
    _isNavigating = false;
    _polylines.clear();
    _selectedPoi = null;
    _userLocationMarker = null; // Kullanƒ±cƒ± marker'ƒ±nƒ± temizle
    notifyListeners();
  }

  // Kullanƒ±cƒ± konum marker'ƒ± olu≈ütur
  Future<void> _createUserLocationMarker(LatLng userLocation) async {
    print('Kullanƒ±cƒ± konum marker\'ƒ± olu≈üturuluyor: ${userLocation.latitude}, ${userLocation.longitude}');
    
    final icon = await _createUserLocationIcon();
    
    _userLocationMarker = Marker(
      markerId: const MarkerId('user_location'),
      position: userLocation,
      icon: icon,
      infoWindow: const InfoWindow(
        title: 'Konumunuz',
        snippet: 'Mevcut konumunuz',
      ),
      zIndex: 1000, // En √ºstte g√∂r√ºns√ºn
    );
  }

  // Kullanƒ±cƒ± konum icon'u olu≈ütur
  Future<BitmapDescriptor> _createUserLocationIcon() async {
    final pictureRecorder = ui.PictureRecorder();
    final canvas = Canvas(pictureRecorder);
    
    // Dƒ±≈ü √ßember (beyaz border)
    final outerPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.fill;
    
    // ƒ∞√ß √ßember (mavi)
    final innerPaint = Paint()
      ..color = const Color(0xFF3252a8)
      ..style = PaintingStyle.fill;
    
    // Pulse efekti i√ßin b√ºy√ºk √ßember (≈üeffaf)
    final pulsePaint = Paint()
      ..color = const Color(0xFF3252a8).withOpacity(0.3)
      ..style = PaintingStyle.fill;
    
    const double size = 40.0;
    const double center = size / 2;
    
    // Pulse √ßember
    canvas.drawCircle(const Offset(center, center), 18, pulsePaint);
    
    // Dƒ±≈ü √ßember (beyaz border)
    canvas.drawCircle(const Offset(center, center), 12, outerPaint);
    
    // ƒ∞√ß √ßember (mavi)
    canvas.drawCircle(const Offset(center, center), 8, innerPaint);
    
    final picture = pictureRecorder.endRecording();
    final img = await picture.toImage(size.toInt(), size.toInt());
    final byteData = await img.toByteData(format: ui.ImageByteFormat.png);
    
    return BitmapDescriptor.fromBytes(byteData!.buffer.asUint8List());
  }

  // Kullanƒ±cƒ± konumunu g√ºncelle (takip sƒ±rasƒ±nda)
  void updateUserLocation(LatLng newLocation) {
    if (!_isNavigating) return;
    
    print('Kullanƒ±cƒ± konumu g√ºncelleniyor: ${newLocation.latitude}, ${newLocation.longitude}');
    
    _createUserLocationMarker(newLocation).then((_) {
      notifyListeners();
      
      // Kamerayƒ± kullanƒ±cƒ± konumunda tut
      _controller?.animateCamera(
        CameraUpdate.newLatLng(newLocation),
      );
    });
  }

  void centerOnMilletBahcesi() {
    _controller?.animateCamera(
      CameraUpdate.newLatLngZoom(kayseriMilletBahcesi, 16.0),
    );
  }

  // Haritayƒ± kullanƒ±cƒ± konumuna odakla
  Future<void> _focusOnUserLocation(LatLng userLocation) async {
    if (_controller != null) {
      print('üéØ Harita kullanƒ±cƒ± konumuna odaklanƒ±yor: ${userLocation.latitude}, ${userLocation.longitude}');
      
      await _controller!.animateCamera(
        CameraUpdate.newCameraPosition(
          CameraPosition(
            target: userLocation,
            zoom: 17.0, // Kullanƒ±cƒ± konumu i√ßin y√ºksek zoom
            tilt: 45.0, // Hafif a√ßƒ±lƒ± g√∂r√ºn√ºm
            bearing: 0.0, // Kuzey y√∂n√º
          ),
        ),
      );
      
      // Animasyon tamamlandƒ±ktan sonra kƒ±sa bir bekleme
      await Future.delayed(const Duration(milliseconds: 500));
    }
  }

  // Kullanƒ±cƒ± konumuna odaklanmak i√ßin public fonksiyon
  Future<void> focusOnUserLocation(LatLng userLocation) async {
    await _focusOnUserLocation(userLocation);
  }
}